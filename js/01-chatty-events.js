/*
 * Сhatty events
 * Приемы throttling и debouncing c Lodash
 */

/*
 * Mousemove и throttle
 */

// Сhatty events - болтливые события, это те события которые срабатывают слишком часто, к примеру, при скроле, ресайзинге(когда
// меняем размер экрана) при движении мышки или MouseMove, при вводе данных в инпут, т.к. срабатывает при вводе каждого
// символа и т.д.
// Браузер может хоть трилион событий регистрировать это без проблем, проблема возникает, когда вызывается обработчик события
// (функция которую мы прописали), вот он то как раз и влияет на производительность. Т.к. множество таких функций забивают
// стек, и другие более важные функции могут ждать своей очереди. В итоге может все тормозить и тупить.

// Это решается с помощью приемов throttling и debouncing c Lodash, используются как правило на болтливых событиях чтобы 
// оптимизироваь производительность (чтобы не вызывать часто функцию и не забивать стек)

// throttle - позволяет, задать интервал при котором будет вызываться функция.Т.е.он говорит, вызови мне эту функцию не
// чаще чем к примеру раз в 300 мс. Т.е. этот прием буквально тормозит вызов функции.


// Посмотрим как это работает на примере применения приема _.throttle при движении мышкой:
const coordsOutputRef = document.querySelector('.js-coords');
let mouseMoveCbInvocationCounter = 0;

// Можно так записать:
// const throttleOnMouseMove = _.throttle(onMouseMove, 500); // запишем переменную в которую возьмем нашу исходную функцию и 
// // через тротл скажем вызываеть её каждые 500 мс, и уже throttleOnMouseMove(исходную функцию с торможением) повесим на 
// // слушатель событий: 
// window.addEventListener('mousemove', throttleOnMouseMove);

// Можно записать прям так:
window.addEventListener('mousemove', _.throttle(onMouseMove, 250));

function onMouseMove(event) {
  mouseMoveCbInvocationCounter += 1;

  coordsOutputRef.textContent = `
    Кол-во вызовов onMouseMove: ${mouseMoveCbInvocationCounter},
    X: ${event.clientX},
    Y:${event.clientY}
  `;
}

/*
 * Input и debounce
 */

// Следующий кейс это использование приема (паттерна) debounce.

// debounce - используется в случае когда нам необходимо использовать отложенный поиск.
// Если _.throttle притормаживает запуск функцию с использованием указанного нами интервала, то _.debounce говорит
// вызови мне функцию только тогда когда прикратиться поток этих событий.

// К примеру мы говорим вызови мне функцию через 300мс, после того как прекратитьс поток событий в области инпут.
// Т.е. буквально мы набираем текст в инпуте(к примеру в поисковой строке), как только мы останавливаемся на 300 мс
// наш прием _.debounce вызовет нашу функцию(обработчик событий, к примеру это будет фильтр по заданному слову в базе
// данных)

// Посмотрим на примере, как только у нас наступает пауза 3 сек или 300 мс у нас срабатывает функция:
const inputRef = document.querySelector('.js-input');
const outputRef = document.querySelector('.js-output');
let inputCbInvocationCounter = 0;

inputRef.addEventListener('input', _.debounce(onInputChange, 300));

function onInputChange(event) {
  inputCbInvocationCounter += 1;

  outputRef.textContent = `
    Кол-во вызовов onInputChange: ${inputCbInvocationCounter},
    Значение: ${event.target.value}
  `;
}

// Т.е._.debounce используется как правило тогда когда заканчивается поток событий и мы обрабатываем результат через 
// функцию (на примере ввода значения в инпут) 